# 欧几里得算法

## 欧几里得算法

```c++
// gcd(a, b) //
int gcd(int a, int b){
	if(b == 0) return a;
	else return gcd(b, a % b);
}
```

## 扩展欧几里得算法

```c++
// a * x + b * y = d = gcd(a, b) //
typedef long long LL;
void exgcd(LL a, LL b, LL &x0, LL &y0, LL &d){
    if(b == 0){
        x0 = 1, y0 = 0, d = a;
        return;
    }
    LL x1, y1;
    exgcd(b, a % b, x1, y1, d);
    x0 = y1, y0 = x1 - (a / b) * y1;
}
int main(){
    LL a, b, x, y, d;
    exgcd(a, b, x, y, d);
}
```

## 类欧几里得算法

一般形式：求 $f(a, b, c, n) = \sum\limits_{i = 0}^{n}\lfloor{\frac{ai+b}{c}}\rfloor$​

$f(a, b, c, n)$​ 可以单独求。

$f(a, b, c, n) = nm-f(c, c - b - 1, a, m - 1)$

```c++
typedef long long LL
LL f(LL a, LL b, LL c, LL n){
	if(a == 0) return ((b / c) * (n + 1));
	if(a >= c || b >= c) 
		return f(a % c, b % c, c, n) + (a / c) * n * (n + 1) / 2 + (b / c) * (n + 1);
	LL m = (a * n + b) / c;
	LL v = f(c, c - b - 1, a, m - 1);
	reutrn n * m - v;
}
```

更进一步，求：$g(a, b, c, n) = \sum\limits_{i = 0}^{n}i\lfloor{\frac{ai+b}{c}}\rfloor$ 以及 $h(a, b, c, n) = \sum\limits_{i = 0}^{n}{\lfloor{\frac{ai+b}{c}}\rfloor}^2$​

直接记吧。

$g(a, b, c, n) = \lfloor{\frac{mn(n+1)-f(c, c-b-1, a, m-1)-h(c, c-b-1, a, m-1)}{2}}\rfloor$​

$h(a, b, c, n) = nm(m+1)-2f(c, c - b-1, a, m- 1)-2g(c,c-b-1,a,m-1)-f(a, b, c, n)$

```c++
typedef long long LL;
const int mod = 998244353;
const int inv2 = 499122177, inv6 = 166374059; // 2和6的逆元 //
LL f(LL a, LL b, LL c, LL n);
LL g(LL a, LL b, LL c, LL n);
LL h(LL a, LL b, LL c, LL n);
struct data{
    LL f, g, h;
};
data calc(LL a, LL b, LL c, LL n){
    LL ac = a / c, bc = b / c, m = (a * n + b) / c, n1 = n + 1, n21 = n * 2 + 1;
    data d;
    if(a == 0){
        d.f = bc * n1 % mod;
        d.g = bc * n % mod * n1 % mod * inv2 % mod;
        d.h = bc * bc % mod * n1 % mod;
        return d;
    }
    if(a >= c || b >= c){
        d.f = n * n1 % mod * inv2 % mod * ac % mod + bc * n1 % mod;
        d.g = ac * n % mod * n1 % mod * n21 % mod * inv6 % mod + bc * n % mod * n1 % mod * inv2 % mod;
        d.h = ac * ac % mod * n % mod * n1 % mod * n21 % mod * inv6 % mod + bc * bc % mod * n1 % mod + ac * bc % mod * n % mod * n1 % mod;
        d.f %= mod, d.g %= mod, d.h %= mod;
        data e = calc(a % c, b % c, c, n);
        d.h += e.h + 2 * bc % mod * e.f % mod + 2 * ac % mod * e.g % mod;
        d.g += e.g, d.f += e.f;
        d.f %= mod, d.g %= mod, d.h %= mod;
        return d;
    }
    data e = calc(c, c - b - 1, a, m - 1);
    d.f = n * m % mod - e.f, d.f = (d.f % mod + mod) % mod;
    d.g = m * n % mod * n1 % mod - e.h - e.f, d.g = (d.g * inv2 % mod + mod) % mod;
    d.h = n * m % mod * (m + 1) % mod - 2 * e.g - 2 * e.f - d.f;
    d.h = (d.h % mod + mod) % mod;
    return d;
}
int main(){
    ···
    data ans = calc(a, b, c, n);
    printf("%lld %lld %lld\n", ans.f, ans.g, ans.h);
}
```

